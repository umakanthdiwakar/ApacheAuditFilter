/*
**  mod_audit_log.c -- Apache sample audit_log module
**  [Autogenerated via ``apxs -n audit_log -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running:
**
**    $ apxs -c -i mod_audit_log.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /audit_log in as follows:
**
**    #   httpd.conf
**    LoadModule audit_log_module modules/mod_audit_log.so
**    <Location /audit_log>
**    SetHandler audit_log
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /audit_log and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/audit_log
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**
**    The sample page from mod_audit_log.c
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include <stdio.h>
#include <apr_general.h>
#include <apr_hash.h>
#include <apr_strings.h>
#define MAX_SIZE 5000

static void decode_html (char *p, char *p1) {
    int i = 0, j = 0;
    char s1[3];
    s1[2] = 0;

    while (*p) {
        if (*p == '%') {
            p++;
            s1[0] = *p++;
            s1[1] = *p++;
            *p1++ = (char)strtol (s1, 0, 16);
        }
        else
            *p1++ = *p++;
    }
    *p1 = 0;
}

static int parse_form_from_POST(request_rec *r, char **form_data)
{
    int bytes, eos;
    apr_size_t count;
    apr_status_t rv;
    apr_bucket_brigade *bb;
    apr_bucket_brigade *bbin;
    char *buf;
    apr_bucket *b;
    const char *clen = apr_table_get(r->headers_in, "Content-Length");
    if (clen != NULL) {
        bytes = strtol(clen, NULL, 0);
        if (bytes >= MAX_SIZE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"Request too big (%d bytes; limit %d)",bytes, MAX_SIZE);
            return HTTP_REQUEST_ENTITY_TOO_LARGE;
        }
    }
    else {
        bytes = MAX_SIZE;
    }

    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    bbin = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    count = 0;
    do {
        rv = ap_get_brigade(r->input_filters, bbin, AP_MODE_READBYTES,APR_BLOCK_READ, bytes);
        if (rv != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,"failed to read form input");
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        for (b = APR_BRIGADE_FIRST(bbin);b != APR_BRIGADE_SENTINEL(bbin);b = APR_BUCKET_NEXT(b) ) {
            if (APR_BUCKET_IS_EOS(b)) {
                eos = 1;
            }
            if (!APR_BUCKET_IS_METADATA(b)) {
                if (b->length != (apr_size_t)(-1)) {
                    count += b->length;
                    if (count > MAX_SIZE) {
                        /* This is more data than we accept, so we're
                        * going to kill the request. But we have to
                        * mop it up first.
                        */
                        apr_bucket_delete(b);
                    }
                }
            }
            if (count <= MAX_SIZE) {
                APR_BUCKET_REMOVE(b);
                APR_BRIGADE_INSERT_TAIL(bb, b);
            }
            if (eos) break;
        }
    } while (!eos);
    /* OK, done with the data. Kill the request if we got too much data. */
    if (count > MAX_SIZE) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,"Request too big (%d bytes; limit %s)",bytes, MAX_SIZE);
        return HTTP_REQUEST_ENTITY_TOO_LARGE;
    }
    /* We've got all the data. Now put it in a buffer and parse it. */
    buf = apr_palloc(r->pool, count+1);
    char *buf1 = apr_palloc(r->pool, count+1);
    rv = apr_brigade_flatten(bb, buf, &count);
    if (rv != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,"Error (flatten) reading form data");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    buf[count] = '\0';
    decode_html (buf, buf1);
    *form_data = buf1;
    return OK;
}

char *form_value(apr_pool_t *pool, apr_hash_t *form, const char *key)
{
    apr_array_header_t *v_arr = apr_hash_get(form, key,APR_HASH_KEY_STRING);
    /* Caveat: this is ambiguous because values may contain commas */
    return apr_array_pstrcat(pool, v_arr, ',');
}


static int auditlog_handler(request_rec *r)
{
    apr_hash_t *formdata = NULL;
    char *form_data;
    int rv = OK;
    if (r->method_number != M_POST) {
        return HTTP_METHOD_NOT_ALLOWED;
    }

    if (r->method_number == M_POST) {
        const char* ctype = apr_table_get(r->headers_in, "Content-Type");
        if (ctype && (strcasecmp(ctype,"application/x-www-form-urlencoded") == 0)) {
            rv = parse_form_from_POST(r, &form_data);
        }
    }
    if (rv != OK) {
        ap_rputs("<p>Error reading form data!</p>", r);
    }
    else if (form_data == NULL) {
        ap_rputs("<p>No form data found.</p>", r);
    }
    else {
        /* Parsed the form successfully, so we have data to display */
        char *a = strcasestr (form_data, "auditlog>");
        if (a) {
            char *audit_log = apr_palloc(r->pool, 512);
            char *b = audit_log;
            for (a += 9; *a && *a != '<'; *b++ = *a++);
            *b = 0;
        apr_table_add (r->headers_in, "uuid", audit_log);
        }
    }
    return OK ;
}



static void audit_log_register_hooks(apr_pool_t *p)
{
    ap_hook_insert_filter(auditlog_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA audit_log_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    audit_log_register_hooks  /* register hooks                      */
};

